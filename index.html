<!DOCTYPE html>
<html>
	<head>
		<title>Bodylogical Demo</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<div id="container"></div>
		<script src="js/libs/three.min.js"></script>
		<script src="js/libs/controls/OrbitControls.js"></script>
		<script src="js/Config.js"></script>
		<script src="js/Detector.js"></script>
		<script src="js/libs/stats.min.js"></script>

		<script type="x-shader/x-vertex" id="vertexshader">
			uniform float amplitude;
			attribute float displacement;
			varying vec3 vNormal;
			varying vec2 vUv;
			void main() {
				vNormal = normal;
				vUv = ( 0.5 + amplitude ) * uv + vec2( amplitude );
				vec3 newPosition = position + amplitude * normal * vec3( displacement );
				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			varying vec3 vNormal;
			varying vec2 vUv;
			uniform vec3 color;
			uniform sampler2D texture;
			void main() {
				vec3 light = vec3( 0.5, 0.2, 1.0 );
				light = normalize( light );
				float dProd = dot( vNormal, light ) * 0.5 + 0.5;
				vec4 tcolor = texture2D( texture, vUv );
				vec4 gray = vec4( vec3( tcolor.r * 0.3 + tcolor.g * 0.59 + tcolor.b * 0.11 ), 1.0 );
				gl_FragColor = gray * vec4( vec3( dProd ) * vec3( color ), 1.0 );
			}
		</script>

		<script>
            if ( ! Detector.webgl ) Detector.addGetWebGLMessage();
            var renderer, scene, camera, stats;
            var plane, ball, planeGeo, ballGeo;
            var planeWidth = 10;
            var planeLength = 50;
            var trenchWidth = 20;
            var ballx, ballz;

            init();
            animate();

            function drawTrench(sx, firstTime) {
                for (var i = 0; i < planeGeo.vertices.length; i+=(grid+1)) {
                    for (var j = i; j < i+(grid+1); j++) {
                        var x = j - i;
                        var y = grid - i / (grid+1);
                        var z = a*Math.pow(x,2) + b*Math.pow(y,2);
                        var cur_sx = d*Math.pow(y,2) + sx;
                        if (x >= cur_sx - trenchWidth/2 && x <= cur_sx + trenchWidth/2) {
                            var theta = (x - cur_sx)/-(trenchWidth/2)*Math.PI;
                            z += c*(Math.cos(theta)+1)*t/tmax;
                        }
                        if (x == parseInt(cur_sx) && y == bally) {
                            ballx = cur_sx;
                            ballz = z;
                        }
                        if (firstTime) {
                            planeGeo.vertices[j].y += (planeLength - planeWidth)/2;
						}
                        planeGeo.vertices[j].z = z;
                    }
                }
            }

            function putBall() {
                ball.position.x = (ballx-grid/2)/grid*planeWidth;
                ball.position.y = (bally-10)/grid*planeLength;
                ball.position.z = ballz + ballRadius;
			}

            function init() {
                camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
                camera.position.z = 10;
                scene = new THREE.Scene();
                planeGeo = new THREE.PlaneGeometry( planeWidth, planeLength, grid, grid );
                planeGeo.dynamic = true;

				drawTrench(sx, true);

                var planeMaterial = new THREE.MeshPhongMaterial({
                    color: 0x6699CC,
                    side: THREE.DoubleSide,
                    wireframe: wireFrameOn,
                    shading: THREE.flatShading,
                    shininess: 20
                });
                plane =  new THREE.Mesh( planeGeo, planeMaterial );
                var group = new THREE.Group();
                scene.add(group);
                group.add(plane);

                ballGeo = new THREE.SphereGeometry( ballRadius, ballComplexity,  ballComplexity);

                var ballMaterial = new THREE.MeshPhongMaterial({
                    color: 0x99FFCC,
                    wireframe: wireFrameOn,
                    shading: THREE.SmoothShading,
                    shininess: 500
                });

                ball = new THREE.Mesh( ballGeo, ballMaterial);

                group.add(ball);
                putBall();

                var materialy = new THREE.LineBasicMaterial({ color: 0x138D75 });

                var yaxisGeo = new THREE.Geometry();
                yaxisGeo.vertices.push( new THREE.Vector3( -5, -5, 0 ), new THREE.Vector3( -5, 5, 0 ) );
                var yaxis = new THREE.Line( yaxisGeo, materialy );
                scene.add( yaxis );

                var materialx = new THREE.LineBasicMaterial({ color: 0xFF0033 });

                var xaxisGeo = new THREE.Geometry();
                xaxisGeo.vertices.push( new THREE.Vector3( -5, -5, 0 ), new THREE.Vector3( 5, -5, 0 ) );
                var xaxis = new THREE.Line( xaxisGeo, materialx );
                scene.add( xaxis );

                var materialz = new THREE.LineBasicMaterial({ color: 0x2471A3 });

                var zaxisGeo = new THREE.Geometry();
                zaxisGeo.vertices.push( new THREE.Vector3( -5, -5, 0 ), new THREE.Vector3( -5, -5, 10 ) );
                var zaxis = new THREE.Line( zaxisGeo, materialz );
                scene.add( zaxis );

                var directionalLight = new THREE.DirectionalLight( 0xffffff, 1 );
                directionalLight.position.set( 20, 20, 20 );
                var directionalLight2 = new THREE.DirectionalLight( 0xffffff, 1 );
                directionalLight2.position.set( -20, -20, -20 );
                scene.add( directionalLight );
                scene.add( directionalLight2 );


                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor( 0xCCCCCC );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );

                var controls = new THREE.OrbitControls( camera, renderer.domElement );
                controls.minDistance = 1;
                controls.maxDistance = 100;



                var container = document.getElementById( 'container' );
                container.appendChild( renderer.domElement );

                stats = new Stats();
                container.appendChild( stats.dom );
                window.addEventListener( 'resize', onWindowResize, false );
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize( window.innerWidth, window.innerHeight );
            }

            function animate() {
                requestAnimationFrame( animate );
                render();
                stats.update();
            }

            var frameCount = 0;

            function render() {
                frameCount += 1;
				planeGeo.verticesNeedUpdate = true;
				drawTrench(sx - frameCount/60, false);
				putBall();
                renderer.render( scene, camera );
            }

		</script>
	</body>
</html>